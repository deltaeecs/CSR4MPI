#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <random>
#include <string>
#include <unordered_set>
#include <vector>

// Simple synthetic MatrixMarket generator (coordinate, real general/symmetric lower)
// Usage: csr4mpi_gen_mm <rows> <cols> <nnz_per_row> <symmetric_lower:0|1> <out_path>
int main(int argc, char** argv)
{
    if (argc < 6) {
        std::fprintf(stderr, "Usage: %s <rows> <cols> <nnz_per_row> <sym_lower 0|1> <out_path>\n", argv[0]);
        return 1;
    }
    long rows = std::strtol(argv[1], nullptr, 10);
    long cols = std::strtol(argv[2], nullptr, 10);
    long nnzPer = std::strtol(argv[3], nullptr, 10);
    int symLower = std::strtol(argv[4], nullptr, 10);
    std::string out = argv[5];
    if (rows <= 0 || cols <= 0 || nnzPer <= 0) {
        std::fprintf(stderr, "Invalid arguments\n");
        return 2;
    }
    std::FILE* f = std::fopen(out.c_str(), "wb");
    if (!f) {
        std::perror("fopen");
        return 3;
    }
    // Header
    if (symLower) {
        std::fprintf(f, "%%%%MatrixMarket matrix coordinate real symmetric\n");
    } else {
        std::fprintf(f, "%%%%MatrixMarket matrix coordinate real general\n");
    }
    std::fprintf(f, "%% Generated by csr4mpi_gen_mm\n");
    // We will generate row-wise unique columns
    std::mt19937 rng(12345);
    long totalNnz = 0;
    std::vector<std::pair<long, long>> ij;
    std::vector<double> val;
    ij.reserve((size_t)rows * (size_t)nnzPer);
    val.reserve(ij.capacity());
    for (long r = 0; r < rows; ++r) {
        std::unordered_set<long> used;
        for (long k = 0; k < nnzPer; ++k) {
            long c;
            int guard = 0;
            do {
                c = (long)(rng() % cols);
                if (symLower) {
                    if (c > r)
                        c = r;
                }
            } while (used.count(c) && ++guard < 1000);
            if (used.count(c))
                continue;
            used.insert(c);
            ij.emplace_back(r, c);
            double v = ((rng() % 2001) - 1000) / 1000.0;
            if (v == 0.0)
                v = 1.0;
            val.push_back(v);
            ++totalNnz;
        }
    }
    std::fprintf(f, "%ld %ld %ld\n", rows, cols, totalNnz);
    for (size_t i = 0; i < ij.size(); ++i) {
        // MatrixMarket uses 1-based indices
        std::fprintf(f, "%ld %ld %.12g\n", ij[i].first + 1, ij[i].second + 1, val[i]);
    }
    std::fclose(f);
    std::fprintf(stdout, "Wrote %ld entries to %s\n", totalNnz, out.c_str());
    return 0;
}
